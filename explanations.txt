Question 1: 
We can check whether two strings are anagram by checking the count of all characters in both string. If all counts are the same, then the two strings are anagram. We can first compile a dictionary of counts for t and check with every possible consecutive substring sets in s. If any set is anagram of t, then we return True, else False. Comparing counts of all characters will can be done in constant time since there are only limited amount of characters to check. Looping through all possible consecutive substrings will take worst case O(len(s)). Therefore the time complexity of this algorithm is O(len(s)). Excluding the space used to load t and s, we only additionally stored the counts of t and counts of s. Since the number of character are bounded, the algorithm will only take space complexity of O(1).

Question 2:
One observation to make is that checking the palindrome will take worst case O(n) time and can be started from the center. Since there are only O(n) location any palindromic substring can be rooted, we can easily check all possible combinations and will only take order O(n^2) time. Excluding the space used to load a, we only need to store left and right index of the longest palindromic substring. Therefore, the space complexity of this algorithm is O(1).

Question 3:


Question 4:


Question 5:
The best way to solve this problem is to just traverse through the linked list twice. The first time we traverse through the linked list to get its length. Then we can determine how many elements to traverse on the second pass to get the mth element from the back. The time will still be O(n) for traverse through ll twice. Since we only store the length, the space complexity will be O(1). One special case to note is to deal with circular linked list. If that case is not treated, then the get_length() function might stuck in a infinite loop when feed a circular linked list. We can use two nodes each traverse at different rate to deal with the case. If both of them ever meet, then we know the linked list is circular and we can terminate the loop. This part will not take additional time in traversal and will only need to store one additional node durning the traversal. Therefore the overall time and space complexity will not be affected. 
